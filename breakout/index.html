<!doctype html><html lang="ja"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" /><title>ブロック崩し</title><style>:root {--bg: #081425;--roto: #3b82f6;--btn: #0f1b2e;}html,body {height: 100%;margin: 0;font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;background: linear-gradient(180deg, var(--bg), #061022);color: #eaf2ff;overflow: hidden;user-select: none   ;}.wrap {display: flex;flex-direction: column;align-items: center;gap: 10px;padding: 12px}h2 {margin: 6px 0 0 0;font-weight: 700;font-size: 18px}canvas {background: linear-gradient(180deg, #0a1831 0%, #0b2242 100%);border-radius: 12px;box-shadow: 0 8px 26px rgba(0, 0, 0, 0.55);touch-action: none;max-width: 96vw;max-height: 60vh}.controls-mobile {display: flex;gap: 16px;align-items: center;justify-content: center;margin-top: 10px;}.controls-mobile button {-webkit-tap-highlight-color: transparent;background: var(--btn);color: #d7e5ff;border: 1px solid rgba(255, 255, 255, 0.12);border-radius: 12px;padding: 16px 22px;font-size: 20px;min-width: 96px;box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);}.controls-mobile .hint {font-size: 12px;color: #9aaacc}</style></head><body><div class="wrap"><h2>ブロック崩し</h2><canvas id="game" width="800" height="520"></canvas><div class="controls-mobile"><button id="btnLeft">◀︎</button><div class="hint">スマホ: ボタンで操作 / PC: ← →</div><button id="btnRight">▶︎</button></div></div><script>(() => { const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d', { alpha: false }); const btnLeft = document.getElementById('btnLeft'); const btnRight = document.getElementById('btnRight'); const btnCenter = new Set([String.fromCodePoint(12354), String.fromCodePoint(12356), String.fromCodePoint(12363), String.fromCodePoint(12371), String.fromCodePoint(12377), String.fromCodePoint(12383), String.fromCodePoint(12399), String.fromCodePoint(12426), String.fromCodePoint(12431)]); const baseW = 800, baseH = 520; function fit() { const r = Math.min(window.innerWidth * 0.96 / baseW, window.innerHeight * 0.60 / baseH); canvas.style.width = baseW * r + 'px'; canvas.style.height = baseH * r + 'px'; } window.addEventListener('resize', fit); fit(); let paused = false; let paddle, ball, bricks = []; let moveLeft = false, moveRight = false; const audioCtx = new (window.AudioContext || window.webkitAudioContext)(); function beep(freq = 440, duration = 0.05, type = 'square', vol = 0.05) { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.value = freq; g.gain.value = vol; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + duration); } function createPaddle() { return { w: 120, h: 14, x: (baseW - 120) / 2, y: baseH - 42, speed: 8 }; } function createBall() { return { r: 8, x: baseW / 2, y: baseH - 64, vx: 0, vy: 0, speed: 6, stuck: true }; } const layout = { cols: 16, rows: 12, marginX: 8, marginTop: 56, gapX: 0, gapY: 0 }; function generateBricks() { const { cols, rows, marginX, marginTop, gapX, gapY } = layout; const bw = Math.floor((baseW - marginX * 2 - (cols - 1) * gapX) / cols); const bh = Math.max(8, Math.floor(bw / 4)); layout.bw = bw; layout.bh = bh; layout.areaW = cols * bw; layout.areaH = rows * bh; layout.areaX = marginX; layout.areaY = marginTop; const out = []; for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { out.push({ x: marginX + c * bw, y: marginTop + r * bh, w: bw, h: bh, alive: true }); } } return out; } function resetAll() { paddle = createPaddle(); ball = createBall(); bricks = generateBricks(); } function collide(b, r) { const cx = Math.max(r.x, Math.min(b.x, r.x + r.w)); const cy = Math.max(r.y, Math.min(b.y, r.y + r.h)); const dx = b.x - cx, dy = b.y - cy; return (dx * dx + dy * dy) <= b.r * b.r ? { dx, dy } : null; } const gojuon = [['あ', 'い', 'う', 'え', 'お'], ['か', 'き', 'く', 'け', 'こ'], ['さ', 'し', 'す', 'せ', 'そ'], ['た', 'ち', 'つ', 'て', 'と'], ['な', 'に', 'ぬ', 'ね', 'の'], ['は', 'ひ', 'ふ', 'へ', 'ほ'], ['ま', 'み', 'む', 'め', 'も'], ['や', '', 'ゆ', '', 'よ'], ['ら', 'り', 'る', 'れ', 'ろ'], ['わ', '', '', '', 'を'], ['', '', '', '', 'ん']]; function drawGojuon() { const ax = layout.areaX, ay = layout.areaY, aw = layout.areaW, ah = layout.areaH; const rows = gojuon.length, cols = 5; const cellW = aw / cols, cellH = ah / rows; const fontSize = Math.floor(Math.min(cellW, cellH) * 1.15); ctx.save(); ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = `700 ${fontSize}px "Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,system-ui,sans-serif`; for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { const ch = gojuon[r][c] || ''; if (!ch) continue; const cx = ax + c * cellW + cellW / 2, cy = ay + r * cellH + cellH / 2; ctx.fillStyle = btnCenter.has(ch) ? '#ff3b3b' : 'rgba(232,240,255,0.20)'; ctx.fillText(ch, cx, cy); } } ctx.restore(); } function render() { const g = ctx.createLinearGradient(0, 0, 0, baseH); g.addColorStop(0, '#0a1831'); g.addColorStop(1, '#0b2242'); ctx.fillStyle = g; ctx.fillRect(0, 0, baseW, baseH); drawGojuon(); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--roto') || '#3b82f6'; for (const b of bricks) { if (b.alive) ctx.fillRect(b.x, b.y, b.w, b.h); } ctx.fillStyle = '#cfe9ff'; ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h); const grad = ctx.createRadialGradient(ball.x - 3, ball.y - 3, ball.r * 0.1, ball.x, ball.y, ball.r); grad.addColorStop(0, '#fff'); grad.addColorStop(0.6, '#a8d8ff'); grad.addColorStop(1, '#4fb0ff'); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2); ctx.fill(); } function update() { if (paused) return; if (moveLeft) paddle.x -= paddle.speed; if (moveRight) paddle.x += paddle.speed; paddle.x = Math.max(8, Math.min(baseW - paddle.w - 8, paddle.x)); if (ball.stuck) { ball.x = paddle.x + paddle.w / 2; ball.y = paddle.y - ball.r - 2; } else { const spd = Math.hypot(ball.vx, ball.vy) || 1; ball.vx = ball.vx / spd * ball.speed; ball.vy = ball.vy / spd * ball.speed; ball.x += ball.vx; ball.y += ball.vy; if (ball.x - ball.r <= 0) { ball.x = ball.r; ball.vx = Math.abs(ball.vx); beep(400, 0.04, 'square', 0.06); } if (ball.x + ball.r >= baseW) { ball.x = baseW - ball.r; ball.vx = -Math.abs(ball.vx); beep(400, 0.04, 'square', 0.06); } if (ball.y - ball.r <= 0) { ball.y = ball.r; ball.vy = Math.abs(ball.vy); beep(500, 0.04, 'square', 0.07); } if (ball.y - ball.r > baseH) { beep(120, 0.15, 'square', 0.1); resetAll(); } const pr = { x: paddle.x, y: paddle.y, w: paddle.w, h: paddle.h }; const pc = collide(ball, pr); if (pc) { const hit = (ball.x - (paddle.x + paddle.w / 2)) / (paddle.w / 2); const angle = hit * (Math.PI / 3); const s = Math.max(5, ball.speed); ball.vx = Math.sin(angle) * s; ball.vy = -Math.abs(Math.cos(angle) * s); ball.y = paddle.y - ball.r - 1; beep(700, 0.05, 'square', 0.07); } for (const b of bricks) { if (!b.alive) continue; const c = collide(ball, b); if (c) { if (Math.abs(c.dx) > Math.abs(c.dy)) ball.vx = -ball.vx; else ball.vy = -ball.vy; b.alive = false; beep(900 + Math.random() * 200, 0.06, 'square', 0.08); break; } } } } function loop() { update(); render(); requestAnimationFrame(loop); } document.addEventListener('keydown', e => { if (e.key === 'ArrowLeft') { moveLeft = true; if (ball.stuck) launch(-1); } if (e.key === 'ArrowRight') { moveRight = true; if (ball.stuck) launch(1); } }); document.addEventListener('keyup', e => { if (e.key === 'ArrowLeft') moveLeft = false; if (e.key === 'ArrowRight') moveRight = false; }); function pressLeft() { moveLeft = true; if (ball.stuck) launch(-1); } function releaseLeft() { moveLeft = false; } function pressRight() { moveRight = true; if (ball.stuck) launch(1); } function releaseRight() { moveRight = false; } btnLeft.addEventListener('pointerdown', e => { e.preventDefault(); pressLeft(); }); btnLeft.addEventListener('pointerup', e => { e.preventDefault(); releaseLeft(); }); btnLeft.addEventListener('pointerleave', releaseLeft); btnRight.addEventListener('pointerdown', e => { e.preventDefault(); pressRight(); }); btnRight.addEventListener('pointerup', e => { e.preventDefault(); releaseRight(); }); btnRight.addEventListener('pointerleave', releaseRight); function launch(dir) { if (!ball.stuck) return; const baseAng = (Math.PI / 10); const ang = dir < 0 ? Math.PI - baseAng : baseAng; ball.stuck = false; ball.vx = Math.cos(ang) * ball.speed * dir; ball.vy = -Math.abs(Math.sin(ang) * ball.speed); beep(800, 0.05, 'square', 0.07); } resetAll(); loop(); })();</script></body></html>